<script>

'use strict';

/*
    CPU emulator - 2015.08.15
    ~~~~~~~~~~~~~~~~~~~~~~~~~
 
    Instuction set:

        -----------+----------------------+----+---------------------------------------+-----------------------------------------------
        cycles     | memory               | nr | instuction                            | action
        -----------+----------------------+----+---------------------------------------+-----------------------------------------------
        ? cycles   | 0x0R 0xRR            | 00 | add     regOut, regIn0, regIn1        | regOut = regIn0 + regIn1
        ? cycles   | 0x1R 0xRR            | 01 | nand    regOut, regIn0, regIn1        | regOut = regIn0 nand regIn1
        ? cycles   | 0x2R 0xRR            | 02 | sh      regOut, regIn0, regIn1        | regOut = (regIn1>=0) ? (regIn0 > abs(regIn1))
        ? cycles   | 0x5_ 0xRR            | 03 | jnz     regIn0, regIn1                | if (regIn1!=0) jump to address from regIn0
        ? cycles   | 0x3R 0xR_            | 04 | copy    regOut, regIn0                | regOut = regIn0
        ? cycles   | 0x4R 0x__ 0xCC 0xCC  | 05 | imm     regOut, _constans16bit_       | regOut = _constans16bit_
        ? cycles   | 0x6_ 0xR_            | 06 | ld      regIn0                        | regMem = MemoryAt[regIn0]
        ? cycles   | 0x7_ 0xR_            | 07 | st      regIn0                        | MemoryAt[regIn0] = regMem
        -----------+----------------------+----+---------------------------------------+-----------------------------------------------

        Alternative version of last three instructions. It can save lot of space in memory after program compilation.

        ...        | ...                  | .. | ...                                   | ...
        ? cycles   | 0x4R 0xCC 0xCC       | 05 | imm     regOut, _constant16bit_       | regOut = _constant16bit_
        ? cycles   | 0x6R                 | 06 | ld      regIn0                        | regMem = MemoryAt[regIn0]
        ? cycles   | 0x7R                 | 07 | st      regIn0                        | MemoryAt[regIn0] = regMem
        -----------+----------------------+----+---------------------------------------+-----------------------------------------------

    Registers:        

        We have 16 egisters. Each can hold 16 bits of data.
    
        reg00-11          Normal
        reg12     regFP   FramePointer
        reg13     regSP   StackPointer
        reg14     regMA   MemoryAccess     (hardware)
        reg15     regPC   ProgramCounter   (hardware)

    Memory:

        Adress bus is 16 bits wide so CPU can access up to 65536 bytes (64 KB). Each memory transfer 16 bits wide so if you
        address 0x0010 memory row you will get 0x0010 and 0x0011 byte inside register. Memory connected to CPU is 32 bits
        wide so it contains 16384 rows 4 bytes each.

        0000: 00 00 00 00
        0004: 00 00 00 00
        0008: 00 00 00 00
        000C: 00 00 00 00
             . . .


        FFD0: po po po po   PORT out - row #0   LCD matrix               ; 1111 1111 1101 0000
        FFD4: po po po po   PORT out - row #1   LCD matrix
        FFD8: po po po po   PORT out - row #2   LCD matrix
        FFDC: po po po po   PORT out - row #3   LCD matrix
        FFE0: po po po po   PORT out - row #4   LCD matrix               ; 1111 1111 1110 0000
        FFE4: po po po po   PORT out - row #5   LCD matrix
        FFE8: po po po po   PORT out - row #6   ---
        FFEC: po po po po   PORT out - row #7   ---
        FFF0: pi pi pi pi   PORT in - row #0    Keyboard                 ; 1111 1111 1111 0000
        FFF4: pi pi pi pi   PORT in - row #1    ---
        FFF8: pi pi pi pi   PORT in - row #2    ---
        FFFC: 00 00 00 00   reserved for 32 bit timer inside CPU

    Pins:

        192 bits of out ports (display)  PORT out 24 bytes
        11 bits in ports (keyboard)      PORT in  1.375 bytes
        2 bits power and ground          in - not nesesary in emulator
        1 bit clock                      in
        1 bit reset                      in
        16 bits memory data in           in
        16 bits memory address           out
        16 bits memory data out          out
        1 bit memory WE                  out
        
    
*/



(function () {

    var Cpu = function () {

        var _this = this;

        this.REG_SEQ = {
            FETCH_FIRST: 0x00,
            FETCH_SECOND: 0x01,
            ADD: 0x02,
            NAND: 0x03
        };

        this.INSTRUCTIONS = {
            ADD: {
                byteWidth: 2
            },
            NAND: {
                byteWidth: 2
            },
            SH: {
                byteWidth: 2
            },
            JNZ: {
                byteWidth: 2
            },
            COPY: {
                byteWidth: 2
            },
            IMM: {
                byteWidth: 4
            },
            LD: {
                byteWidth: 2
            },
            ST: {
                byteWidth: 2
            }

            /*
                ? cycles   | 0x0R 0xRR            | 00 | add     regOut, regIn0, regIn1        | regOut = regIn0 + regIn1
                ? cycles   | 0x1R 0xRR            | 01 | nand    regOut, regIn0, regIn1        | regOut = regIn0 nand regIn1
                ? cycles   | 0x2R 0xRR            | 02 | sh      regOut, regIn0, regIn1        | regOut = (regIn1>=0) ? (regIn0 > abs(regIn1))
                ? cycles   | 0x5_ 0xRR            | 03 | jnz     regIn0, regIn1                | if (regIn1!=0) jump to address from regIn0
                ? cycles   | 0x3R 0xR_            | 04 | copy    regOut, regIn0                | regOut = regIn0
                ? cycles   | 0x4R 0x__ 0xCC 0xCC  | 05 | imm     regOut, _constans16bit_       | regOut = _constans16bit_
                ? cycles   | 0x6_ 0xR_            | 06 | ld      regIn0                        | regMem = MemoryAt[regIn0]
                ? cycles   | 0x7_ 0xR_            | 07 | st      regIn0                        | MemoryAt[regIn0] = regMem
            */
        };

        this.inputs = {
            clock: false,
            reset: false,
            memoryRead: 0x00000000
        };

        this.outputs = {
            memoryAddress: 0x0000,
            memoryWrite: 0x00000000,
            memoryWE: false
        };

        this.registers = {
            // data registers
            reg00: 0xFFFF & Math.random() * 0x10000,
            reg01: 0xFFFF & Math.random() * 0x10000,
            reg02: 0xFFFF & Math.random() * 0x10000,
               /* ..03-13.. */
            regMA: 0xFFFF & Math.random() * 0x10000,
            regPC: 0xFFFF & Math.random() * 0x10000,

            // control registers
            regSeq: 0xFF & Math.random() * 0x100,
            regInstr: 0xFFFF & Math.random() * 0x10000,

            // input helper registers
            regReset: Math.random() >= 0.5,
            regMemory: 0xFFFFFFFF & Math.random() * 0x100000000
        };

        var clockPrevious = null;


        this.boot = function () {
            setOutputsAfterBoot();
        };

        function setOutputsAfterBoot()
        {
            // TODO read regSeq and check if address bus is pulled down or driven by some other part of the cpu

            // for now we assume that default output is provided after cpu starts
        }

        this.update = function () {

            if (clockPrevious === null) {
                clockPrevious = this.inputs.clock;
                return;
            }

            if (clockPrevious !== this.inputs.clock) {
                if (this.inputs.clock) {
                    clockLowToHigh();
                } else {
                    clockHighToLow();
                }
            }    
        };

        function clockLowToHigh() 
        {
            // nothing is happening here - data is passed internally inside masterâ€“slave D flip-flop registers
        }

        function clockHighToLow()
        {
            var resetAndBreak = false;

            if (_this.registers.regReset) {
                performRegistersReset();
                setOutputsAfterReset();
                resetAndBreak = true;
                return;
            }

            _this.registers.regReset = _this.inputs.reset;         // store current input
            if (resetAndBreak) {
                return;
            }

            switch (_this.registers.regSeq) {
                case _this.REG_SEQ.FETCH_FIRST: 
                    sequenceFetchFirst();
                    break;
                case _this.REG_SEQ.FETCH_SECOND: 
                    sequenceFetchSecond();
                    break;
                case _this.REG_SEQ.FETCH_SECOND: 
                    sequenceFetchSecond();
                    break;
            }
        }

        function performRegistersReset()
        {
            _this.registers.reg00 = 0x0000;
            _this.registers.reg01 = 0x0000;
            _this.registers.reg02 = 0x0000;
            _this.registers.regMA = 0x0000;
            _this.registers.regPC = 0x0000;

            _this.registers.regSeq = 0x00;
            _this.registers.regInstr = 0x0000;

            _this.registers.regMemory = 0x00000000;

            // !!! regReset register is excluded from reset !!!
        }

        function setOutputsAfterReset()
        {
            _this.outputs.memoryAddress = 0x0000;        // after reset regSeq points to fetchFirst instruction - address comes from regPC that was reset too
            _this.outputs.memoryWrite = 0x00000000;      // this outpus comes from memoryWriteBus that is, by fetchFirst instruction, pulled down by rezistors
            _this.outputs.memoryWE = false;              // this comes from microProgram and for fetchFirst it's false
        }

        function sequenceFetchFirst()
        {
            var addressRow = _this.registers.regPC >>> 2,
                addressCol = _this.registers.regPC & 0x3,
                byteShifted = _this.inputs.memoryRead << addressCol;

            _this.registers.regMemory = byteShifted;
            _this.registers.regSeq = _this.REG_SEQ.FETCH_SECOND;
        }

        function sequenceFetchSecond()
        {
            
        }

        this.boot();
    };


    var cpu = new Cpu();

    cpu.inputs.reset = true;


    console.log('clock: ' + cpu.inputs.clock + ' | ' + JSON.stringify(cpu.registers) + ' | ' + JSON.stringify(cpu.inputs));

    function runCpu() 
    {
        var clockTicks = 0;

        while (clockTicks < 10) {
            cpu.inputs.clock = true;
            cpu.update();
            console.log('clock: ' + cpu.inputs.clock + ' | ' + JSON.stringify(cpu.registers) + ' | ' + JSON.stringify(cpu.inputs));

            cpu.inputs.clock = false;
            cpu.update();
            console.log('clock: ' + cpu.inputs.clock + ' | ' + JSON.stringify(cpu.registers) + ' | ' + JSON.stringify(cpu.inputs));

            console.log('clockTicks ', clockTicks, cpu.registers.regPC);
            clockTicks++;
        }
    }


    runCpu();


})();

</script>