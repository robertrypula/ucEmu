<script>

'use strict';

/*
    CPU emulator - 2015.08.15
    ~~~~~~~~~~~~~~~~~~~~~~~~~
 
    Instuction set:

        -----------+----------------------+----+---------------------------------------+-----------------------------------------------
        cycles     | memory               | nr | instuction                            | action
        -----------+----------------------+----+---------------------------------------+-----------------------------------------------
        ? cycles   | 0x0R 0xRR            | 00 | add     regOut, regIn0, regIn1        | regOut = regIn0 + regIn1
        ? cycles   | 0x1R 0xRR            | 01 | nand    regOut, regIn0, regIn1        | regOut = regIn0 nand regIn1
        ? cycles   | 0x2R 0xRR            | 02 | sh      regOut, regIn0, regIn1        | regOut = (regIn1>=0) ? (regIn0 > abs(regIn1))
        ? cycles   | 0x3_ 0xRR            | 03 | jnz     regIn0, regIn1                | if (regIn1!=0) jump to address from regIn0
        ? cycles   | 0x4R 0xR_            | 04 | copy    regOut, regIn0                | regOut = regIn0
        ? cycles   | 0x5R 0x__ 0xCC 0xCC  | 05 | imm     regOut, _constans16bit_       | regOut = _constans16bit_
        ? cycles   | 0x6_ 0xR_            | 06 | ld      regIn0                        | regMem = MemoryAt[regIn0]
        ? cycles   | 0x7_ 0xR_            | 07 | st      regIn0                        | MemoryAt[regIn0] = regMem
        -----------+----------------------+----+---------------------------------------+-----------------------------------------------

        Alternative version of last three OPCODES. It can save lot of space in memory after program compilation.

        ...        | ...                  | .. | ...                                   | ...
        ? cycles   | 0x4R 0xCC 0xCC       | 05 | imm     regOut, _constant16bit_       | regOut = _constant16bit_
        ? cycles   | 0x6R                 | 06 | ld      regIn0                        | regMem = MemoryAt[regIn0]
        ? cycles   | 0x7R                 | 07 | st      regIn0                        | MemoryAt[regIn0] = regMem
        -----------+----------------------+----+---------------------------------------+-----------------------------------------------

    Registers:        

        We have 16 egisters. Each can hold 16 bits of data.
    
        reg00-11          Normal
        reg12     regFP   FramePointer
        reg13     regSP   StackPointer
        reg14     regMA   MemoryAccess     (hardware)
        reg15     regPC   ProgramCounter   (hardware)

    Memory:

        Adress bus is 16 bits wide so CPU can access up to 65536 bytes (64 KB). Each memory transfer 16 bits wide so if you
        address 0x0010 memory row you will get 0x0010 and 0x0011 byte inside register. Memory connected to CPU is 32 bits
        wide so it contains 16384 rows 4 bytes each.

        0000: 00 00 00 00
        0004: 00 00 00 00
        0008: 00 00 00 00
        000C: 00 00 00 00
             . . .


        FFD0: po po po po   PORT out - row #0   LCD matrix               ; 1111 1111 1101 0000
        FFD4: po po po po   PORT out - row #1   LCD matrix
        FFD8: po po po po   PORT out - row #2   LCD matrix
        FFDC: po po po po   PORT out - row #3   LCD matrix
        FFE0: po po po po   PORT out - row #4   LCD matrix               ; 1111 1111 1110 0000
        FFE4: po po po po   PORT out - row #5   LCD matrix
        FFE8: po po po po   PORT out - row #6   ---
        FFEC: po po po po   PORT out - row #7   ---
        FFF0: pi pi pi pi   PORT in - row #0    Keyboard                 ; 1111 1111 1111 0000
        FFF4: pi pi pi pi   PORT in - row #1    ---
        FFF8: pi pi pi pi   PORT in - row #2    ---
        FFFC: 00 00 00 00   reserved for 32 bit timer inside CPU

    Pins:

        192 bits of out ports (display)  PORT out 24 bytes
        11 bits in ports (keyboard)      PORT in  1.375 bytes
        2 bits power and ground          in - not nesesary in emulator
        1 bit clock                      in
        1 bit reset                      in
        16 bits memory data in           in
        16 bits memory address           out
        16 bits memory data out          out
        1 bit memory WE                  out
        
    
*/



(function () {

    var Cpu = function () {

        var _this = this;

        this.REG_SEQ = {
            FETCH_FIRST: 0x00,
            FETCH_SECOND: 0x01,
            ADD: 0x02,
            NAND: 0x03
        };

        this.OPCODES = {
            ADD: {
                code: 0,
                name: 'add',
                byteWidth: 2
            },
            NAND: {
                code: 1,
                name: 'nand',
                byteWidth: 2
            },
            SH: {
                code: 2,
                name: 'sh',
                byteWidth: 2
            },
            JNZ: {
                code: 3,
                name: 'jnz',
                byteWidth: 2
            },
            COPY: {
                code: 4,
                name: 'copy',
                byteWidth: 2
            },
            IMM: {
                code: 5,
                name: 'imm',
                byteWidth: 4
            },
            LD: {
                code: 6,
                name: 'ld',
                byteWidth: 2
            },
            ST: {
                code: 7,
                name: 'st',
                byteWidth: 2
            }

            /*
                ? cycles   | 0x0R 0xRR            | 00 | add     regOut, regIn0, regIn1        | regOut = regIn0 + regIn1
                ? cycles   | 0x1R 0xRR            | 01 | nand    regOut, regIn0, regIn1        | regOut = regIn0 nand regIn1
                ? cycles   | 0x2R 0xRR            | 02 | sh      regOut, regIn0, regIn1        | regOut = (regIn1>=0) ? (regIn0 > abs(regIn1))
                ? cycles   | 0x3_ 0xRR            | 03 | jnz     regIn0, regIn1                | if (regIn1!=0) jump to address from regIn0
                ? cycles   | 0x4R 0xR_            | 04 | copy    regOut, regIn0                | regOut = regIn0
                ? cycles   | 0x5R 0x__ 0xCC 0xCC  | 05 | imm     regOut, _constans16bit_       | regOut = _constans16bit_
                ? cycles   | 0x6_ 0xR_            | 06 | ld      regIn0                        | regMem = MemoryAt[regIn0]
                ? cycles   | 0x7_ 0xR_            | 07 | st      regIn0                        | MemoryAt[regIn0] = regMem
            */
        };

        this.inputs = {
            clock: false,
            reset: false,
            memoryRead: 0x00000000
        };

        this.outputs = {
            memoryAddress: 0x0000,
            memoryWrite: 0x00000000,
            memoryWE: false,

            portRow00: 0x00000000,
            portRow01: 0x00000000,
            portRow02: 0x00000000,
            portRow03: 0x00000000,
            portRow04: 0x00000000,
            portRow05: 0x00000000,
            portRow06: 0x00000000,
            portRow07: 0x00000000
        };

        this.outputPortsRegisters = {
            regPortRow00: 0xFFFFFFFF & Math.random() * 0x100000000,
            regPortRow01: 0xFFFFFFFF & Math.random() * 0x100000000,
            regPortRow02: 0xFFFFFFFF & Math.random() * 0x100000000,
            regPortRow03: 0xFFFFFFFF & Math.random() * 0x100000000,
            regPortRow04: 0xFFFFFFFF & Math.random() * 0x100000000,
            regPortRow05: 0xFFFFFFFF & Math.random() * 0x100000000,
            regPortRow06: 0xFFFFFFFF & Math.random() * 0x100000000,
            regPortRow07: 0xFFFFFFFF & Math.random() * 0x100000000
        };

        this.registers = {
            // data registers
            reg00: 0xFFFF & Math.random() * 0x10000,
            reg01: 0xFFFF & Math.random() * 0x10000,
            reg02: 0xFFFF & Math.random() * 0x10000,
            reg03: 0xFFFF & Math.random() * 0x10000,
               /* ..04-13.. */
            regMA: 0xFFFF & Math.random() * 0x10000,
            regPC: 0xFFFF & Math.random() * 0x10000,

            // control registers
            regSeq: 0xFF & Math.random() * 0x100,
            regInstr: 0xFFFF & Math.random() * 0x10000,

            // input helper registers
            regReset: Math.random() >= 0.5,
            regMemory: 0xFFFFFFFF & Math.random() * 0x100000000,

            // timer
            regTimer: 0xFFFFFFFF & Math.random() * 0x100000000
        };

        var clockPrevious = null;


        this.boot = function () {
            _this.update();
        };

        this.update = function () {

            if (clockPrevious === null) {
                clockPrevious = this.inputs.clock;
            }

            if (clockPrevious !== this.inputs.clock) {
                if (this.inputs.clock) {
                    clockLowToHigh();
                } else {
                    clockHighToLow();
                }
                clockPrevious = this.inputs.clock;
            }

            updateOutputs();
        };

        function clockLowToHigh() 
        {
            // nothing is happening here - data is passed internally inside masterâ€“slave D flip-flop registers
        }

        function clockHighToLow()
        {
            var resetOccured = false;

            if (_this.registers.regReset) {
                performRegistersReset();
                resetOccured = true;
            }

            _this.registers.regReset = _this.inputs.reset;         // store current input
            if (resetOccured) {
                return;
            }

            switch (_this.registers.regSeq) {
                case _this.REG_SEQ.FETCH_FIRST: 
                    sequenceFetchFirst();
                    break;
                case _this.REG_SEQ.FETCH_SECOND: 
                    sequenceFetchSecond();
                    break;
                case _this.REG_SEQ.ADD: 
                    sequenceAdd();
                    break;
                case _this.REG_SEQ.NAND: 
                    sequenceNand();
                    break;
                case _this.REG_SEQ.SH: 
                    sequenceSh();
                    break;
            }

            // TODO increase timer
        }

        function performRegistersReset()
        {
            _this.registers.reg00 = 0x0000;
            _this.registers.reg01 = 0x0000;
            _this.registers.reg02 = 0x0000;
            _this.registers.reg03 = 0x0000;
            _this.registers.regMA = 0x0000;
            _this.registers.regPC = 0x0000;

            _this.registers.regSeq = 0x00;
            _this.registers.regInstr = 0x0000;

            _this.registers.regMemory = 0x00000000;
            _this.registers.regTimer = 0x00000000;

            console.log('RESET!!');

            // !!! regReset register is excluded from reset !!!
        }

        function updateOutputs()
        {
            // memoryAddress
            switch (_this.registers.regSeq) {
                case _this.REG_SEQ.FETCH_FIRST:
                case _this.REG_SEQ.ADD:
                case _this.REG_SEQ.NAND:
                case _this.REG_SEQ.SH:
                // TOOD more
                    _this.outputs.memoryAddress = _this.registers.regPC;
                    break;
                case _this.REG_SEQ.FETCH_SECOND:
                    _this.outputs.memoryAddress = _this.registers.regPC + 4;
                    break;
                // TODO more 
                default:
                    _this.outputs.memoryAddress = 0x0000;            // floating bus - pulled down by resistors
            }

            // memoryWrite
            switch (_this.registers.regSeq) {
                default: 
                    _this.outputs.memoryWrite = 0x00000000;  // TODO implement st operation
            }
            
            // memoryWE
            switch (_this.registers.regSeq) {
                default: 
                    _this.outputs.memoryWE = false;          // TODO implement st operation
            }
            
        }

        function sequenceFetchFirst()
        {
            console.log('    :: sequenceFetchFirst');
            var addressRow = _this.outputs.memoryAddress >>> 2,
                addressCol = _this.outputs.memoryAddress & 3,
                memoryReadShifted = _this.inputs.memoryRead << (addressCol * 8);

            console.log('    addressRow = ' + dumpHex(addressRow));
            console.log('    addressCol = ' + dumpHex(addressCol));
            console.log('    inputs.memoryRead = ' + dumpHex(_this.inputs.memoryRead));
            console.log('    memoryReadShifted = ' + dumpHex(memoryReadShifted));

            _this.registers.regMemory = memoryReadShifted;
            _this.registers.regSeq = _this.REG_SEQ.FETCH_SECOND;
        }

        function sequenceFetchSecond()
        {
            console.log('    :: sequenceFetchSecond');
            var addressRow = _this.outputs.memoryAddress >>> 2,
                addressCol = _this.outputs.memoryAddress & 3,
                memoryReadShifted = _this.inputs.memoryRead >>> ((4 - addressCol) * 8),
                memoryFinal = memoryReadShifted | _this.registers.regMemory,
                opCode = (memoryFinal & 0xF0000000) >>> (7 * 4),
                opCodeDetails = getOpCodeDetails(opCode),
                opCodeByteWidth = opCodeDetails ? opCodeDetails.byteWidth : 0,
                regPCNext = _this.registers.regPC + opCodeByteWidth,
                regSeqNext = 0;

            switch (opCode) {
                case _this.OPCODES.ADD.code: regSeqNext = _this.REG_SEQ.ADD; break;
                case _this.OPCODES.NAND.code: regSeqNext = _this.REG_SEQ.NAND; break;
            }

            console.log('    addressRow = ' + dumpHex(addressRow));
            console.log('    addressCol = ' + dumpHex(addressCol));
            console.log('    inputs.memoryRead = ' + dumpHex(_this.inputs.memoryRead));
            console.log('    memoryReadShifted = ' + dumpHex(memoryReadShifted));
            console.log('    memoryFinal = ' + dumpHex(memoryFinal));
            console.log('    opCode = ' + opCode);
            console.log('    opCodeDetails = ', opCodeDetails);
            console.log('    opCodeByteWidth = ' + opCodeByteWidth);
            console.log('    regPCNext = ' + regPCNext);
            console.log('    regSeqNext = ' + regSeqNext);

            _this.registers.regInstr = memoryFinal;
            _this.registers.regPC = regPCNext;
            _this.registers.regSeq = regSeqNext;

            /*
            0x00 0x00 0xaa 0xbb
            0xcc 0xdd 0x00 0x00

            first
            0xaa 0xbb ____ ____     << aCol with zero fill

            second

            ____ ____ 0xcc 0xdd     >> 4-aCol width zero fill
            */
        }

        function sequenceAdd()
        {
            console.log('    :: sequenceAdd');
            var addressRow = _this.outputs.memoryAddress >>> 2,
                addressCol = _this.outputs.memoryAddress & 3,
                memoryReadShifted = _this.inputs.memoryRead << (addressCol * 8),
                regOut = (_this.registers.regInstr & 0x0F000000) >>> (6 * 4),
                regIn0 = (_this.registers.regInstr & 0x00F00000) >>> (5 * 4),
                regIn1 = (_this.registers.regInstr & 0x000F0000) >>> (4 * 4),
                regIn0Value = readRegister(regIn0),
                regIn1Value = readRegister(regIn1),
                regResult = (regIn1Value + regIn0Value) & 0xFFFF;

            console.log('    addressRow = ' + dumpHex(addressRow));
            console.log('    addressCol = ' + dumpHex(addressCol));
            console.log('    inputs.memoryRead = ' + dumpHex(_this.inputs.memoryRead));
            console.log('    memoryReadShifted = ' + dumpHex(memoryReadShifted));
            console.log('    regOut, regIn0, regIn1 <-> ' + regOut + ', ' + regIn0 + ', ' + regIn1);
            console.log('    regIn0Value = ' + dumpHex(regIn0Value));
            console.log('    regIn1Value = ' + dumpHex(regIn1Value));
            console.log('    result = ' + dumpHex(regResult) + ' (sum)');

            _this.registers.regMemory = memoryReadShifted;
            _this.registers.regSeq = _this.REG_SEQ.FETCH_SECOND;
            saveRegister(regOut, regResult);
        }

        function sequenceNand()
        {
            console.log('    :: sequenceNand');
            var addressRow = _this.outputs.memoryAddress >>> 2,
                addressCol = _this.outputs.memoryAddress & 3,
                memoryReadShifted = _this.inputs.memoryRead << (addressCol * 8),
                regOut = (_this.registers.regInstr & 0x0F000000) >>> (6 * 4),
                regIn0 = (_this.registers.regInstr & 0x00F00000) >>> (5 * 4),
                regIn1 = (_this.registers.regInstr & 0x000F0000) >>> (4 * 4),
                regIn0Value = readRegister(regIn0),
                regIn1Value = readRegister(regIn1),
                regResult = ~(regIn1Value & regIn0Value);

            console.log('    addressRow = ' + dumpHex(addressRow));
            console.log('    addressCol = ' + dumpHex(addressCol));
            console.log('    inputs.memoryRead = ' + dumpHex(_this.inputs.memoryRead));
            console.log('    memoryReadShifted = ' + dumpHex(memoryReadShifted));
            console.log('    regOut, regIn0, regIn1 <-> ' + regOut + ', ' + regIn0 + ', ' + regIn1);
            console.log('    regIn0Value = ' + dumpHex(regIn0Value));
            console.log('    regIn1Value = ' + dumpHex(regIn1Value));
            console.log('    result = ' + dumpHex(regResult) + ' (NAND)');

            _this.registers.regMemory = memoryReadShifted;
            _this.registers.regSeq = _this.REG_SEQ.FETCH_SECOND;
            saveRegister(regOut, regResult);
        }

        function sequenceSh()
        {
            console.log('    :: sequenceSh');
        }

        function getOpCodeDetails(opcode) 
        {
            switch (opcode) {
                case 0: return _this.OPCODES.ADD; break;
                case 1: return _this.OPCODES.NAND; break;
                case 2: return _this.OPCODES.SH; break;
                case 3: return _this.OPCODES.JNZ; break;
                case 4: return _this.OPCODES.COPY; break;
                case 5: return _this.OPCODES.IMM; break;
                case 6: return _this.OPCODES.LD; break;
                case 7: return _this.OPCODES.ST; break;
            }
        }

        function readRegister(number) 
        {
            switch (number) {
                case 0: return _this.registers.reg00; break;
                case 1: return _this.registers.reg01; break;
                case 2: return _this.registers.reg02; break;
                case 3: return _this.registers.reg03; break;
                case 14: return _this.registers.regMA; break;
                case 15: return _this.registers.regPC; break;
            }

            throw 'ReadRegister - Bad number: ' + number;
        }

        function saveRegister(number, value) 
        {
            value = 0xFFFF & value;
            switch (number) {
                case 0: _this.registers.reg00 = value; break;
                case 1: _this.registers.reg01 = value; break;
                case 2: _this.registers.reg02 = value; break;
                case 3: _this.registers.reg03 = value; break;
                case 14: _this.registers.regMA = value; break;
                case 15: _this.registers.regPC = value; break;
                default: throw 'SaveRegister - Bad number ' + number;
            }
        }

        this.boot();
    };

    var StaticRam = function (row, writeEnable, dataIn) {
        var _this = this,
            data = [],
            inputs = {
                row: row,
                writeEnable: writeEnable,
                dataIn: dataIn
            };

        this.log = function (startRow, stopRow) {
            startRow = startRow < 0 ? -startRow : startRow;
            for (var i = startRow; i < (64*1024) / 4; i++) {
                if (i > stopRow) {
                    return;
                }
                console.log(
                    ' StaticRam:  ' + 
                    i.toString(16) + ' | ' + 
                    ((data[i] & 0xFF000000) >>> (6 * 4)).toString(16) + ' ' +
                    ((data[i] & 0x00FF0000) >>> (4 * 4)).toString(16) + ' ' +
                    ((data[i] & 0x0000FF00) >>> (2 * 4)).toString(16) + ' ' +
                    (data[i] & 0x000000FF).toString(16)
                );
            }
        };

        this.getDataOut = function () {
            return data[inputs.row];
        };

        this.setWriteEnable = function (writeEnable) {
            inputs.writeEnable = writeEnable ? true : false;
            update();
        };

        this.setRow = function (row) {
            inputs.row = row & 0x3FFF;
            update();
        };

        this.setDataIn = function (dataIn) {
            inputs.dataIn = dataIn & 0xFFFFFFFF;
            update();
        };

        function update() {
            if (inputs.writeEnable) {
                data[inputs.row] = inputs.dataIn;
            }
        }

        function init() {
            for (var i = 0; i < (64*1024) / 4; i++) {
                data.push(0xFFFFFFFF & Math.random() * 0x100000000);
            }
            update();
        }

        init();
    };

    var memoryState = [
        { row: 0x0000, data: [ 0xAB, 0xCD, 0xEF, 0x12 ] },
        { row: 0x0001, data: [ 0x31, 0x56, 0x11, 0x22 ] },
        { row: 0x0002, data: [ 0xAA, 0xFF, 0x00, 0xFF ] },
        { row: 0x0003, data: [ 0xEE, 0x00, 0xFF, 0x00 ] }
    ];
    var cpu = new Cpu();
    cpuLog();
    var staticRam = new StaticRam(
        cpu.outputs.memoryAddress >>> 2, 
        cpu.outputs.memoryWE, 
        cpu.outputs.memoryWrite
    );
    cpuLog();
    syncCpuWithStaticRam();
    cpuLog();
    console.log("\n");


    // console.log('clock: ' + cpu.inputs.clock + ' | ' + JSON.stringify(cpu.registers) + ' | ' + JSON.stringify(cpu.inputs));
    triggerCpuResetAndProgramStaticRam();    
    // console.log('clock: ' + cpu.inputs.clock + ' | ' + JSON.stringify(cpu.registers) + ' | ' + JSON.stringify(cpu.inputs));




    cpu.registers.regPC = 3;
    globalUpdate();
    runCpu();






    function triggerCpuResetAndProgramStaticRam()
    {
        console.log(':: trigger RESET AND PROGRAM STARTS');

        cpu.inputs.reset = true;
        clockHigh();
        clockLow();

        programStaticRam(memoryState);
        syncCpuWithStaticRam();

        cpu.inputs.reset = false;
        clockHigh();
        clockLow();

        syncCpuWithStaticRam();

        console.log(':: trigger RESET AND PROGRAM ENDS');
        console.log("\n\n");
    }

    function runCpu()
    {
        var clockTicks = 0;        

        while (clockTicks < 3) {
            clockHigh();
            clockLow();

            console.log('----> clockTicks ', clockTicks);
            console.log("\n");
            clockTicks++;
        }
    }

    function programStaticRam(memoryState)
    {
        staticRam.setWriteEnable(false);
        for (var i = 0; i < memoryState.length; i++) {
            var ms = memoryState[i];

            staticRam.setRow(ms.row);
            staticRam.setDataIn(
                0x1000000 * ms.data[0] + 
                0x10000 * ms.data[1] + 
                0x100 * ms.data[2] + 
                ms.data[3]
            );
            staticRam.setWriteEnable(true);
            staticRam.setWriteEnable(false);
        }
    }

    function syncCpuWithStaticRam() 
    {
        staticRam.setRow(cpu.outputs.memoryAddress >>> 2);
        staticRam.setWriteEnable(cpu.outputs.memoryWE);
        staticRam.setDataIn(cpu.outputs.memoryWrite);

        cpu.inputs.memoryRead = staticRam.getDataOut();
    }

    function clockHigh()
    {
        cpu.inputs.clock = true;
        globalUpdate();
        cpuLog();
    }

    function clockLow()
    {
        cpu.inputs.clock = false;
        globalUpdate();
        cpuLog();
    }

    function globalUpdate()
    {
        cpu.update();
        syncCpuWithStaticRam();
    }

    function cpuLog()
    {
        console.log(
            'in.clock: ' + cpu.inputs.clock + ' | ' + 
            'in.memoryRead = ' + dumpHex(cpu.inputs.memoryRead) + ' | ' +
            'in.reset = ' + (cpu.inputs.reset ? "true" : "false") + ' |___| ' +
            'out.memoryAddress = ' + dumpHex(cpu.outputs.memoryAddress) + ' | ' +
            'out.memoryWrite = ' + dumpHex(cpu.outputs.memoryWrite) + ' | ' +
            'out.memoryWE = ' + (cpu.outputs.memoryWE ? "true" : "false") + ' |___| ' +
            'regPC = ' + dumpHex(cpu.registers.regPC) + ' | ' +
            'regMem = ' + dumpHex(cpu.registers.regMemory) + ' | ' + 
            'regSeq = ' + dumpHex(cpu.registers.regSeq) + ' | ' + 
            'regInstr = ' + dumpHex(cpu.registers.regInstr) + ' | ' +
            'regReset = ' + (cpu.registers.regReset ? "true" : "false")
        );
    }

    staticRam.log(0, 6);

    function dumpHex(data)
    {
        return ((data & 0xFF000000) >>> (6 * 4)).toString(16) + ' ' +
        ((data & 0x00FF0000) >>> (4 * 4)).toString(16) + ' ' +
        ((data & 0x0000FF00) >>> (2 * 4)).toString(16) + ' ' +
        (data & 0x000000FF).toString(16);
    }

})();

</script>