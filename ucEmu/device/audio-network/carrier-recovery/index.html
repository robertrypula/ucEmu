<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
    </head>
    <body>

        <canvas width="3000" height="128" id="buffer-raw" style="border: 1px solid red;"></canvas>
        <canvas width="3000" height="128" id="buffer-carrier" style="border: 1px solid green;"></canvas>
        <canvas width="3000" height="128" id="buffer-multiply-raw-by-carrier" style="border: 1px solid green;"></canvas>
        <!--<canvas width="3000" height="128" id="buffer-integral" style="border: 1px solid green;"></canvas>-->
        <!--<canvas width="3000" height="128" id="buffer-threshold" style="border: 1px solid green;"></canvas>-->


        <input type="number" id="samples-per-period" onChange="onSamplesPerPeriodChange(this)" value="40" />

        <script src="carrier-recovery.factory.js"></script>
        <script src="carrier-recovery-builder.service.js"></script>

        <script>

            var
                samplesPerPeriod = 40,
                omegaFirst = (2 * Math.PI) / (samplesPerPeriod + 0),
                omegaSecond = (2 * Math.PI) / (samplesPerPeriod + 40),
                carrierRecovery = CarrierRecoveryBuilder.build(samplesPerPeriod),
                bufferRaw = [],
                bufferCar = [],
                bufferMul = [],
                bufferInt = [],
                bufferThr = [],
                dataFirst = [
                    { amplitude: +0.00, phaseOffset: +0.00, omega: 1.00 * omegaFirst, duration: 2.40 * samplesPerPeriod },
                    { amplitude: +1.00, phaseOffset: +0.25, omega: 1.00 * omegaFirst, duration: 4.00 * samplesPerPeriod },
                    { amplitude: +1.00, phaseOffset: +0.50, omega: 1.00 * omegaFirst, duration: 4.00 * samplesPerPeriod },
                    { amplitude: +1.00, phaseOffset: +0.25, omega: 1.00 * omegaFirst, duration: 4.00 * samplesPerPeriod },
                    { amplitude: +1.00, phaseOffset: +0.75, omega: 1.00 * omegaFirst, duration: 4.00 * samplesPerPeriod },
                    { amplitude: +1.00, phaseOffset: +0.00, omega: 1.00 * omegaFirst, duration: 4.00 * samplesPerPeriod },
                    { amplitude: +1.00, phaseOffset: +0.25, omega: 1.00 * omegaFirst, duration: 4.00 * samplesPerPeriod },
                    { amplitude: +0.00, phaseOffset: +0.00, omega: 1.00 * omegaFirst, duration: 11.47 * samplesPerPeriod }
                ],
                dataSecond = [
                    { amplitude: +0.00, phaseOffset: +0.00, omega: 1.00 * omegaSecond, duration: 5.40 * samplesPerPeriod },
                    { amplitude: +0.50, phaseOffset: +0.00, omega: 1.00 * omegaSecond, duration: 4.00 * samplesPerPeriod },
                    { amplitude: +0.50, phaseOffset: +0.00, omega: 1.00 * omegaSecond, duration: 4.00 * samplesPerPeriod },
                    { amplitude: +0.50, phaseOffset: +0.00, omega: 1.00 * omegaSecond, duration: 4.00 * samplesPerPeriod },
                    { amplitude: +0.50, phaseOffset: +0.00, omega: 1.00 * omegaSecond, duration: 4.00 * samplesPerPeriod },
                    { amplitude: +0.50, phaseOffset: +0.00, omega: 1.00 * omegaSecond, duration: 4.00 * samplesPerPeriod },
                    { amplitude: +0.50, phaseOffset: +0.00, omega: 1.00 * omegaSecond, duration: 4.00 * samplesPerPeriod },
                    { amplitude: +0.00, phaseOffset: +0.00, omega: 1.00 * omegaSecond, duration: 11.47 * samplesPerPeriod }
                ];

            function onSamplesPerPeriodChange(input) {
                carrierRecovery.setSamplesPerPeriod(parseInt(input.value));
                nextFrame();
            }

            function fillBuffer(buffer, start, stop, mix, sampleCallback) {
                var i, x;

                for (i = start; i < stop; i++) {
                    x = i - start;

                    if (mix) {
                        buffer[i] += sampleCallback(x);
                    } else {
                        buffer.push(sampleCallback(x))
                    }
                }
            }

            function createBufferRaw(bufferRaw, data, mix) {
                var start = 0, stop = 0, i, d;

                for (i = 0; i < data.length; i++) {
                    d = data[i];
                    start = stop;
                    stop = start + d.duration;
                    fillBuffer(bufferRaw, start, stop, mix, function (x) {
                        return (
                            d.amplitude *
                            Math.sin(
                              d.omega * x - 2 * Math.PI * d.phaseOffset
                            )
                        );
                    });
                }
            }

            function addNoise(buffer) {
                var i;

                for (i = 0; i < buffer.length; i++) {
                    buffer[i] += ((Math.random() * 2) - 1.0) * 0.2;
                }
            }

            function draw(canvasId, buffer) {
                var i;
                var canvas = document.getElementById(canvasId);
                var ctx = canvas.getContext("2d");
                var offsetY;

                ctx.lineWidth = 1;
                ctx.strokeStyle = 'rgba(150, 50, 150, 1)';
                ctx.clearRect(0, 0, 3000, 128);
                for (i = 0; i < buffer.length; i++) {
                    offsetY = Math.round(buffer[i] * 64);
                    ctx.beginPath();
                    ctx.moveTo(i, 64);
                    ctx.lineTo(i, 64 - (offsetY === 0 ? 1 : offsetY));
                    ctx.closePath();
                    ctx.stroke();
                }
            }

            function createBufferCarrier(bufferRaw, bufferCar) {
                var i, carrierSample;

                for (i = 0; i < bufferRaw.length; i++) {
                    carrierRecovery.handleSample(bufferRaw[i]);
                    carrierSample = carrierRecovery.getCarrier();

                    bufferCar.push(carrierSample);
                }
            }

            function createBufferMultiplyRawByCarrier(bufferRaw, bufferCar, bufferMul) {
                var i;

                for (i = 0; i < bufferRaw.length; i++) {
                    bufferMul.push(
                        bufferRaw[i] * bufferCar[i]
                    );
                }
            }


            function nextFrame() {
                bufferRaw.length = 0;
                bufferCar.length = 0;
                bufferMul.length = 0;
                bufferInt.length = 0;
                bufferThr.length = 0;

                createBufferRaw(bufferRaw, dataFirst, false);
                //createBufferRaw(bufferRaw, dataSecond, true);
                //addNoise(bufferRaw);
                createBufferCarrier(bufferRaw, bufferCar);
                createBufferMultiplyRawByCarrier(bufferRaw, bufferCar, bufferMul);

                draw('buffer-raw', bufferRaw);
                draw('buffer-carrier', bufferCar);
                draw('buffer-multiply-raw-by-carrier', bufferMul);
                //draw('buffer-integral', bufferInt);
                //draw('buffer-threshold', bufferThr);
            }

            nextFrame();

        </script>
    </body>
</html>