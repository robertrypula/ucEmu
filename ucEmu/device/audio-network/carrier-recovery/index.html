<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
    </head>
    <body>

        <div>Sample</div>
        <canvas width="3000" height="128" id="buffer-sample" style="border: 1px solid red;"></canvas>
        <div>Power [dB]</div>
        <canvas width="3000" height="128" id="buffer-power" style="border: 1px solid green;"></canvas>
        <div>Phase</div>
        <canvas width="3000" height="128" id="buffer-phase" style="border: 1px solid green;"></canvas>

        <div>Constellation</div>
        <canvas width="512" height="512" id="constellation-diagram" style="border: 1px solid green;"></canvas>


        <input type="number" id="samples-per-period" onChange="onSamplesPerPeriodChange(this)" value="40" />

        <script src="../audio-util/audio-util.js"></script>
        <script src="carrier-recovery.factory.js"></script>
        <script src="carrier-recovery-builder.service.js"></script>

        <script>

            var
                samplesPerPeriodFirst = 40,
                samplesPerPeriodSecond = 60,
                samplesPerPeriodThird = 80,
                omegaFirst = (2 * Math.PI) / samplesPerPeriodFirst,
                omegaSecond = (2 * Math.PI) / samplesPerPeriodSecond,
                omegaThird = (2 * Math.PI) / samplesPerPeriodThird,
                carrierRecovery = CarrierRecoveryBuilder.build(samplesPerPeriodFirst, 1024),
                bufferSample = [],
                bufferPower = [],
                bufferPhase = [],
                dataFirst = [
                    { amplitude: +0.00, phaseOffset: +0.000, omega: 1.00 * omegaFirst, duration: 5.00 * samplesPerPeriodFirst },
                    { amplitude: +0.30, phaseOffset: +0.125 + 0.000, omega: 1.00 * omegaFirst, duration: 16.00 * samplesPerPeriodFirst },
                    { amplitude: +0.00, phaseOffset: +0.000, omega: 1.00 * omegaFirst, duration: 10.00 * samplesPerPeriodFirst }
                ],
                dataSecond = [
                    { amplitude: +0.00, phaseOffset: +0.000, omega: 1.00 * omegaSecond, duration: 5.00 * samplesPerPeriodSecond },
                    { amplitude: +0.30, phaseOffset: +0.125 + 0.250, omega: 1.00 * omegaSecond, duration: 16.00 * samplesPerPeriodSecond },
                    { amplitude: +0.00, phaseOffset: +0.000, omega: 1.00 * omegaSecond, duration: 10.00 * samplesPerPeriodSecond }
                ],
                dataThird = [
                    { amplitude: +0.00, phaseOffset: +0.000, omega: 1.00 * omegaThird, duration: 5.00 * samplesPerPeriodThird },
                    { amplitude: +0.30, phaseOffset: +0.125 + 0.500, omega: 1.00 * omegaThird, duration: 16.00 * samplesPerPeriodThird },
                    { amplitude: +0.00, phaseOffset: +0.000, omega: 1.00 * omegaThird, duration: 10.00 * samplesPerPeriodThird }
                ];

            function onSamplesPerPeriodChange(input) {
                carrierRecovery.setSamplePerPeriod(parseInt(input.value));
                nextFrame();
            }

            function fillBuffer(buffer, start, stop, sampleCallback) {
                var i, x;

                for (i = start; i < stop; i++) {
                    x = i - start;

                    if (i < buffer.length) {
                        buffer[i] += sampleCallback(x);
                    } else {
                        buffer[i] = sampleCallback(x);
                    }
                }
            }

            function fillBufferSample(bufferSample, data) {
                var start = 0, stop = 0, i, d;

                for (i = 0; i < data.length; i++) {
                    d = data[i];
                    start = stop;
                    stop = start + d.duration;
                    fillBuffer(bufferSample, start, stop, function (x) {
                        return (
                            d.amplitude *
                            Math.sin(
                              d.omega * x - 2 * Math.PI * d.phaseOffset
                            )
                        );
                    });
                }
            }

            function addNoise(buffer) {
                var i;

                for (i = 0; i < buffer.length; i++) {
                    buffer[i] += ((Math.random() * 2) - 1.0) * 0.2;
                }
            }

            function draw(canvasId, buffer) {
                var i;
                var canvas = document.getElementById(canvasId);
                var ctx = canvas.getContext("2d");
                var offsetY;

                ctx.lineWidth = 1;
                ctx.strokeStyle = 'rgba(150, 150, 250, 1)';
                ctx.clearRect(0, 0, 3000, 128);
                for (i = 0; i < buffer.length; i++) {
                    offsetY = Math.round(buffer[i] * 64);
                    ctx.beginPath();
                    ctx.moveTo(i, 64);
                    ctx.lineTo(i, 64 - (offsetY === 0 ? 1 : offsetY));
                    ctx.closePath();
                    ctx.stroke();
                }
            }

            function drawConstellationDiagram(canvasId, bufferPhase, bufferPower) {
                var i;
                var canvas = document.getElementById(canvasId);
                var ctx = canvas.getContext("2d");
                var x, y;

                ctx.fillStyle = 'rgba(130, 130, 230, 1)';

                ctx.lineWidth = 1;
                ctx.strokeStyle = 'rgba(130, 130, 230, 1)';
                ctx.clearRect(0, 0, 512, 512);
                ctx.beginPath();
                ctx.moveTo(0, 256);
                ctx.lineTo(512, 256);
                ctx.closePath();
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(256, 0);
                ctx.lineTo(256, 512);
                ctx.closePath();
                ctx.stroke();
                for (i = 0; i < bufferPhase.length; i++) {
                    if (i < 512 || i > 1024) {
                        continue;
                    }
                    x = 256 + 256 * bufferPower[i] * Math.cos(2 * Math.PI * bufferPhase[i]);
                    y = 256 - 256 * bufferPower[i] * Math.sin(2 * Math.PI * bufferPhase[i]);
                    ctx.fillRect(x - 1, y - 1, 3, 3);
                }
            }

            function analyzeBufferSample(bufferSample, bufferPower, bufferPhase) {
                var i, carrierSample, powerNormalized;

                for (i = 0; i < bufferSample.length; i++) {
                    carrierRecovery.handleSample(bufferSample[i]);
                    carrierSample = carrierRecovery.getCarrier();

                    if (0) {
                        powerNormalized = carrierSample.power;
                    } else {
                        powerNormalized = (carrierSample.powerDecibel + 100) / 100;
                        powerNormalized = powerNormalized < 0 ? 0 : powerNormalized;
                    }

                    bufferPower.push(powerNormalized);
                    bufferPhase.push(carrierSample.phase);
                }
            }

            function nextFrame() {
                bufferSample.length = 0;
                bufferPower.length = 0;
                bufferPhase.length = 0;

                fillBufferSample(bufferSample, dataFirst);
                fillBufferSample(bufferSample, dataSecond);
                fillBufferSample(bufferSample, dataThird);

                //addNoise(bufferSample);

                analyzeBufferSample(bufferSample, bufferPower, bufferPhase);

                draw('buffer-sample', bufferSample);
                draw('buffer-power', bufferPower);
                draw('buffer-phase', bufferPhase);
                drawConstellationDiagram('constellation-diagram', bufferPhase, bufferPower);
            }

            nextFrame();

        </script>
    </body>
</html>